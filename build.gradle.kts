import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

plugins {
    kotlin("jvm") version "2.3.0"
    kotlin("plugin.serialization") version "2.3.0"
    application
    id("com.gradleup.shadow") version "9.3.0"
}

val versionMajor = 0
val versionMinor = 0
val versionPatch = 1
val versionTail = "-alpha-evaluation"  // like: -dev

/** Only used to tell Gradle re-generate Version.kt. */
val nonce = "32ca4021-c181-46f4-86be-fb2458c82cc1"

group = "io.github.flowerblackg"
version = "$versionMajor.$versionMinor.$versionPatch$versionTail"

repositories {
    mavenCentral()
}

dependencies {
    // https://mvnrepository.com/artifact/org.jetbrains.kotlinx/kotlinx-coroutines-core
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2")
    // https://mvnrepository.com/artifact/org.jetbrains.kotlinx/kotlinx-serialization-json
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.9.0")
    // https://mvnrepository.com/artifact/org.jetbrains.kotlinx/kotlinx-serialization-protobuf
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-protobuf:1.9.0")

    // https://mvnrepository.com/artifact/org.jetbrains.kotlinx/kotlinx-io-core
    implementation("org.jetbrains.kotlinx:kotlinx-io-core:0.8.2")

    implementation(kotlin("reflect"))

    // https://mvnrepository.com/artifact/org.json/json
    implementation("org.json:json:20250517")

    // https://mvnrepository.com/artifact/io.netty/netty-all
    implementation("io.netty:netty-all:4.2.9.Final")
    // https://mvnrepository.com/artifact/io.netty/netty-pkitesting
    implementation("io.netty:netty-pkitesting:4.2.9.Final")



    testImplementation(kotlin("test"))
}


val generateVersionFile by tasks.registering {
    val outputDir = layout.buildDirectory.dir("generated/source/kotlin")
    outputs.dir(outputDir)

    inputs.property("versionMajor", versionMajor)
    inputs.property("versionMinor", versionMinor)
    inputs.property("versionPatch", versionPatch)
    inputs.property("versionTail", versionTail)
    inputs.property("nonce", nonce)

    doLast {
        val file = outputDir.get().asFile.resolve("io/github/flowerblackg/janus/Version.kt")
        file.parentFile.mkdirs()

        val currentTime = ZonedDateTime.now().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)

        file.writeText($$"""
            // SPDX-License-Identifier: MulanPSL-2.0
            
            // Generated by build.gradle.kts. DO NOT EDIT.

            package io.github.flowerblackg.janus

            object Version {
                val major: Int = $$versionMajor
                val minor: Int = $$versionMinor
                val patch: Int = $$versionPatch
                val tail: String = "$$versionTail"
                val name = "$major.$minor.$patch$tail"
                val time = "$$currentTime"
            }
        """.trimIndent())
    }
}


kotlin {
    jvmToolchain(25)
    sourceSets.main {
        kotlin.srcDir(generateVersionFile)
    }
}

application {
    mainClass = "io.github.flowerblackg.janus.MainKt"
}

tasks.test {
    useJUnitPlatform()
}


data class Platform(
    val key: String = "",
    val classifiers: Classifiers = Classifiers()
) {
    data class Classifiers(
        val nettyTcnativeBoringsslStatic: String = ""
    )
}


val platforms = setOf(
    Platform(
        key = "windows-x86_64",
        classifiers = Platform.Classifiers(
            nettyTcnativeBoringsslStatic = "windows-x86_64"
        )
    ),

    Platform(
        key = "linux-x86_64",
        classifiers = Platform.Classifiers(
            nettyTcnativeBoringsslStatic = "linux-x86_64"
        )
    ),

    Platform(
        key = "macos-aarch64",
        classifiers = Platform.Classifiers(
            nettyTcnativeBoringsslStatic = "osx-aarch_64"
        )
    ),
).associateBy { it.key }

val platformTaskProviders = mutableListOf<TaskProvider<out Task>>()

platforms.forEach { (platformKey, platform) ->
    val platformImplementation = configurations.create("${platformKey}-implementation").apply {
        extendsFrom(configurations.implementation.get())
        isCanBeResolved = false
        isCanBeConsumed = false
    }
    val platformApi = configurations.create("${platformKey}-api").apply {
        extendsFrom(configurations.api.get())
        isCanBeResolved = false
        isCanBeConsumed = false
    }
    val platformCompileOnly = configurations.create("${platformKey}-compileOnly").apply {
        extendsFrom(configurations.compileOnly.get())
        isCanBeResolved = false
        isCanBeConsumed = false
    }
    val platformRuntimeClasspath = configurations.create("${platformKey}-runtimeClasspath").apply {
        extendsFrom(platformCompileOnly, platformApi, platformImplementation, configurations.runtimeOnly.get())
        isCanBeResolved = true
        isCanBeConsumed = false
    }

    dependencies {
        // https://mvnrepository.com/artifact/io.netty/netty-tcnative-boringssl-static
        platformImplementation("io.netty:netty-tcnative-boringssl-static:2.0.74.Final") {
            artifact {
                classifier = platform.classifiers.nettyTcnativeBoringsslStatic
            }
        }
    }

    val packageTaskName = "package-$platformKey"
    val platformPackageTask = tasks.register(packageTaskName, com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar::class) {
        from(sourceSets["main"].output)
        mainClass = application.mainClass.get()
        configurations = listOf(platformRuntimeClasspath)
        archiveBaseName = project.name
        archiveClassifier = platformKey
        archiveVersion = project.version.toString()
        destinationDirectory = layout.buildDirectory.dir("libs")
        isZip64 = true
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        exclude("META-INF/*.SF")
        exclude("META-INF/*.DSA")
        exclude("META-INF/*.RSA")
        exclude("META-INF/*.EC")
        exclude("META-INF/SIG-*")
    }

    platformTaskProviders += platformPackageTask

    tasks.register("build-$platformKey") {
        group = "build"
        description = "Builds the shadow jar for $platformKey"
        dependsOn(platformPackageTask, tasks.compileKotlin, tasks.compileJava)
    }
}


val packageAll by tasks.registering(Task::class) {
    dependsOn(platformTaskProviders)
    group = "build"
}
